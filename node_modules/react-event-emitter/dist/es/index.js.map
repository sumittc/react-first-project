{"version":3,"sources":["../../src/index.ts"],"names":["createElement","useRef","useEffect","useState","styleProps","display","EventEmitter","children","eventType","detail","waitUntil","Promise","resolve","bubbles","cancelable","composed","domRef","isWaiting","setIsWaiting","then","current","dispatchEvent","CustomEvent","style","ref"],"mappings":"AAAA,OAASA,aAAT,CAAwBC,MAAxB,CAAgCC,SAAhC,CAAsDC,QAAtD,KAAsE,OAAtE,C,GAaMC,CAAAA,UAAU,CAAG,CAAEC,OAAO,CAAE,UAAX,C,CAEbC,YAAY,CAAG,KAQI,IARH,CACpBC,QAAQ,CAARA,CAAQ,CAAG,IADS,CAEpBC,SAAS,CAATA,CAFoB,CAGpBC,MAAM,CAANA,CAHoB,CAIpBC,SAAS,CAATA,CAAS,CAAGC,OAAO,CAACC,OAAR,EAJQ,CAKpBC,OAAO,CAAPA,CALoB,CAMpBC,UAAU,CAAVA,CANoB,CAOpBC,QAAQ,CAARA,CAPoB,CAQG,GACjBC,CAAM,CAAGf,MAAM,CAAiB,IAAjB,CADE,CAGjB,CAACgB,CAAD,CAAYC,CAAZ,EAA4Bf,QAAQ,IAHnB,CAmBvB,MAdAD,CAAAA,SAAS,CAAC,IAAM,CACdQ,CAAS,CAACS,IAAV,CAAe,IAAMD,CAAY,IAAjC,CACD,CAFQ,CAEN,CAACR,CAAD,CAFM,CAcT,CATAR,SAAS,CAAC,IAAM,CACV,CAACc,CAAM,CAACI,OAAR,EAAmBH,CADT,EAGdD,CAAM,CAACI,OAAP,CAAeC,aAAf,CACE,GAAIC,CAAAA,WAAJ,CAAgBd,CAAhB,CAA2B,CAAEC,MAAM,CAANA,CAAF,CAAUI,OAAO,CAAPA,CAAV,CAAmBC,UAAU,CAAVA,CAAnB,CAA+BC,QAAQ,CAARA,CAA/B,CAA3B,CADF,CAGD,CANQ,CAMN,CAACE,CAAD,CAAYT,CAAZ,CAAuBC,CAAvB,CAA+BI,CAA/B,CAAwCC,CAAxC,CAAoDC,CAApD,CANM,CAST,CAAOf,aAAa,CAAC,KAAD,CAAQ,CAAEuB,KAAK,CAAEnB,UAAT,CAAqBoB,GAAG,CAAER,CAA1B,CAAR,CAA4CT,CAA5C,CACrB,C,CAED,cAAeD,CAAAA,YAAf","sourcesContent":["import { createElement, useRef, useEffect, ReactNode, useState } from 'react';\n\ninterface EventEmitterProps {\n  children?: ReactNode;\n  eventType: string;\n  detail?: any;\n  waitUntil?: Promise<any>;\n  bubbles?: boolean;\n  cancelable?: boolean;\n  composed?: boolean;\n}\n\n// just to make sure that the component we use doesn't have any effect on layout\nconst styleProps = { display: 'contents' };\n\nconst EventEmitter = ({\n  children = null,\n  eventType,\n  detail,\n  waitUntil = Promise.resolve(),\n  bubbles,\n  cancelable,\n  composed,\n}: EventEmitterProps) => {\n  const domRef = useRef<HTMLDivElement>(null);\n\n  const [isWaiting, setIsWaiting] = useState(true);\n\n  useEffect(() => {\n    waitUntil.then(() => setIsWaiting(false));\n  }, [waitUntil]);\n\n  // send or resend an event according to props\n  useEffect(() => {\n    if (!domRef.current || isWaiting) return;\n    // send a DOM event\n    domRef.current.dispatchEvent(\n      new CustomEvent(eventType, { detail, bubbles, cancelable, composed }),\n    );\n  }, [isWaiting, eventType, detail, bubbles, cancelable, composed]);\n\n  // render a container to dispatch the DOM event from\n  return createElement('div', { style: styleProps, ref: domRef }, children);\n};\n\nexport default EventEmitter;\n"],"file":"index.js"}